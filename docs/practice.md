# Lab 05 - Swagger and Swashbuckle

We are now going to implement the Swagger Specification on our Web Api, generate API documentation, including a UI to explore and test operations, directly from our controller, by using ```Swashbuckle.AspNetCore```.

Once we have an API that can describe itself in Swagger, we are going to change our client data layer using the Swagger JS library, the Swagger javascript client for use with swagger enabled APIs, the fastest way to enable a javascript client to communicate with a swagger-enabled server.    

## Swagger

The Swagger Specification creates the RESTful contract for your API, detailing all of its resources and operations in a human and machine readable format for easy development, discovery, and integration.

## Swashbuckle.AspNetCore

### Getting Started

Install the standard Nuget package (currently pre-release) into your MarketPlaceService application.

```
Install-Package Swashbuckle.AspNetCore -Pre
```

In the ```ConfigureServices``` method of ```Startup.cs```, register the Swagger generator, defining one or more Swagger documents.

```cs
///requires using Swashbuckle.AspNetCore.Swagger;
services.AddSwaggerGen(c =>
{
    c.SwaggerDoc("v1", new Info { Title = "MarketPlace APIs", Version = "v1" });
});
```

In the ```Configure``` method, insert middleware to expose the generated Swagger as JSON endpoint(s)

```cs
app.UseSwagger();
```

At this point, you can spin up your application and view the generated Swagger JSON at "/swagger/v1/swagger.json"

Insert the swagger-ui middleware to expose interactive documentation, specifying the Swagger JSON endpoint(s) to power it from.

```cs
app.UseSwaggerUI(c =>
{
    c.SwaggerEndpoint("/swagger/v1/swagger.json", "MarketPlace API V1");
});
```

Now you can restart your application and check out the auto-generated, interactive docs at "/swagger".

By default, Swashbuckle will generate a "200" response for each operation. If the action returns a response DTO, then this will be used to generate a "schema" for the response body. We need to specify a different status code and/or additional responses, because some of our actions return IActionResult instead of a response DTO. We can describe explicit responses with the ```ProducesResponseTypeAttribute``` that ships with ASP.NET Core.

Open your ```ProductsController``` in the MarketPlaceService / Controllers folder and find the ```GetAll``` action. Annotate the method with the following attribute:

```cs
///requires using Microsoft.AspNetCore.Http;
[ProducesResponseType(typeof(IEnumerable<Product>), StatusCodes.Status200OK)]
```    

Annotate the ```GetById``` Action with the following attributes:

```cs
[ProducesResponseType(typeof(Product), StatusCodes.Status200OK)]
[ProducesResponseType(typeof(void), StatusCodes.Status404NotFound)]
```

Annotate the ```Create``` Action with the following attributes:

```cs
[ProducesResponseType(typeof(Product), StatusCodes.Status201Created)]
[ProducesResponseType(typeof(void), StatusCodes.Status400BadRequest)]
```

Annotate the ```Update``` Action with the following attributes:

```cs
[ProducesResponseType(typeof(void), StatusCodes.Status400BadRequest)]
[ProducesResponseType(typeof(void), StatusCodes.Status404NotFound)]
[ProducesResponseType(typeof(void), StatusCodes.Status204NoContent)]
```

Annotate the ```Delete``` Action with the following attributes:

```cs
[ProducesResponseType(typeof(void), StatusCodes.Status404NotFound)]
[ProducesResponseType(typeof(void), StatusCodes.Status204NoContent)]
```

Run the application and navigate to ```http://localhost:5000/swagger/#/Products```. You will see that every operations has multiple Response Messages.

Let's also specify that our API produces JSON. 

Open the ```ProductsController``` and decorate the class definition with the following attribute:

```cs
[Produces("application/json")]
```

Navigate to ```http://localhost:5000/swagger/v1/swagger.json```. You will notice that the Operation IDs are the following:

- /api/Products/{id} (get): ApiProductsByIdGet
- /api/Products (get) : ApiProductsGet
- post: ApiProductsPost
- put: ApiProductsByIdPut
- delete: ApiProductsByIdDelete

This means that the client generated by the Swagger JS library will have methods with these names. It's not really ideal, so let's improve it by using the ```SwaggerOperation``` attribute.

Open your ProductsController.cs, find the ```GetAll``` Action and decorate it with the following attribute:

```cs
//requires using Swashbuckle.AspNetCore.SwaggerGen;
[SwaggerOperation("getProducts")]
```

Open your ProductsController.cs, find the ```GetById``` Action and decorate it with the following attribute:

```cs
[SwaggerOperation("getProduct")]
```

Open your ProductsController.cs, find the ```Create``` Action and decorate it with the following attribute:

```cs
[SwaggerOperation("createProduct")]
```

Open your ProductsController.cs, find the ```Update``` Action and decorate it with the following attribute:

```cs
[SwaggerOperation("updateProduct")]
```

Open your ProductsController.cs, find the ```Delete``` Action and decorate it with the following attribute:

```cs
[SwaggerOperation("deleteProduct")]
```

Now the Operations IDs listed on the http://localhost:5000/swagger/v1/swagger.js file are the ones we added on the attributes.

### The JavaScriptClient

We are now ready to switch to our JavaScriptClient project to improve the DataLayer class.

We will use Swagger Js, a javascript library to connect to swagger-enabled APIs via browser or node.js.

Open the JavaScriptClient ```package.json``` file. Modify the ```dependencies``` section as follows:

```json
"dependencies": {
    "vue": "^2.2.4",
    "swagger-client" : "^2.1.32"
}
``` 

**IMPORTANT: Swashbuckle is not yet compatible with swagger-client 3. Add Version 2.1.32 and NOT version 3** 

Save the file in order for Visual Studio to download the package.

Now add a reference to the script in your ```DataLayer.js``` page. 
In the Solution Explorer, open the ```JavaScriptClient/wwwroot/js/src/datalayer.js``` file. At the top of the bage, before the declaration of the class, add the following code:

```js
import Swagger from "swagger-client"
```

Now let's update the rest of the code of out ```DataLayer``` to use SwaggerClient.

First of all, the url that we're going to call is not the one of the service but the one of the swagger.js file that will provide the documentation for our service.

```js
this.serviceUrl = "http://localhost:5000/api/products";
```

with this code

```js
this.url = `http://localhost:5000/swagger/v1/swagger.json`;
```

We're going to update all our methods to use an instance of a SwaggerClient instead of a fetch.

- A ```SwaggerClient``` instance requires an ```options``` object in the constructor, where we can pass 
    - the ```url``` of the description document 
    - the fact that we want to ```use promises``` (as we already did using the fetch method) 
- The SwaggerClient constructor will asynchronously navigate to given the url and return a promise
    - We will continue with a ```then``` method
    - We will receive a dynamically generated ```client``` object, into which we will find properties that mimic our services (```Products``` and ```Values```)
    - The ```Products``` property will have the methods we described on our service (```getProducts```, ```getProduct```, ```createProduct```, ```updateProduct``` and ```deleteProduct```)
    - We will invoke those methods, eventually passing objects with additional data if necessary (the id and / or the product object we need to send to the service) 
    - Each of these methods will in turn return a promise 
        - We can again continue with a ```then``` 
        - We can get the result in a ```data``` parameter injected in our continuation method 
        - The ```data``` parameter has an ```obj``` property where we can find the deserialized result (which could be an array of products, a product, or nothing depending on the method we invoked).

Let's start by modifying the ```getAllProducts``` method by replacing its content with:

```js
getAllProducts() {
    return new Swagger({
        url: this.url,
        usePromise: true
    }).then(client => client.Products.getProducts())
    .then(data => data.obj);
}
```

Replace the content of the ```getProductById``` method with

```js
getProductById(id) {
    return new Swagger({
        url: this.url,
        usePromise: true
    }).then(client => client.Products.getProduct({ id }))
    .then(data => data.obj);
}
```

Replace the content of the ```insertProduct``` method with

```js
insertProduct(product) {
    return new Swagger({
        url: this.url,
        usePromise: true
    }).then(client => client.Products.createProduct({ product }))
    .then(data => data.obj);
}
```

Replace the content of the ```updateProduct``` method with

```js
updateProduct(id, product) {
    return new Swagger({
        url: this.url,
        usePromise: true
    }).then(client => client.Products.updateProduct({ id, product }))
    .then(data => data.obj);
}
```

Replace the content of the ```deleteProduct``` method with

```js
deleteProduct(id) {
    return new Swagger({
        url: this.url,
        usePromise: true
    }).then(client => client.Products.deleteProduct({ id }))
    .then(data => data.obj);
}
```

Save ```datalayer.js```.
Run Webpack by opening a console window on your JavaScript project folder containing webpack.config.js and typing ```webpack```.
Go back to Visual Studio and run the application by pressing on F5, then right click on the Solution Explorer -> JavaScriptClient and select Debug -> Start New instance.

Verify that the page still works by adding, modifying and deleting products.

As you can see, our DataLayer does not need to know anything about http addresses, verbs, content types and so on. We just work by invoking methods, passing parameters and getting the results. The swagger-client takes care of all the underlying plumbing for us.
The creation of an eventual C# client (for example a mobile client made with Xamarin or a web site made with an ASP.NET Core MVC Controller) would also be very simple, thanks to the AutoRest code generator.

We did not implement any security yet. Our next lab will start with setup and configure a new project that will act as an Authentication Server. We will then protect the Create operation and we will use the Authentication Server to authenticate the user and have the client gain access to the protected operation. 

# Next steps

```
git add .
git commit -m "student: step 5 complete"
git checkout step06start
```